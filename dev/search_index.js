var documenterSearchIndex = {"docs":
[{"location":"notes/#Notes","page":"Notes","title":"Notes","text":"","category":"section"},{"location":"notes/#Dimensionless-units","page":"Notes","title":"Dimensionless units","text":"","category":"section"},{"location":"notes/","page":"Notes","title":"Notes","text":"In atomistic model, sometimes we will use the dimensionless units, i.e.,","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"J = hbar = gamma = k_B = S = a = 1","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"In this situation, we have magnetic moment mu_s = hbar gamma S = 1. The following  conversion table can be used to convert the simulation results to physical units.","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"note: Unit conversion table for J = 1meV, S = 1, and a = 0.5 nm.\nParameter Conversion coefficients Value\nDistance x hatx=a 0.5nm\nTime t hatt=hbar SJ 0.66 ps\nMagnetic field H hatH = J(hbar gamma S) 8.63T\nVelocity v hatv = Ja(hbar S) 759.63 m/s\nFrequency omega hatomega = J(hbar S) 1519.3 GHz\nTemperature T hatT = Jk_B 11.6 K","category":"page"},{"location":"notes/#Reducing-the-startup-time","page":"Notes","title":"Reducing the startup time","text":"","category":"section"},{"location":"notes/","page":"Notes","title":"Notes","text":"Julia is a dynamically-typed language, so the input script will be compiled when we start a simulation. However, the typical startup time in our case ranges from 1s to 30s depends on the complexity of the problem. It is painful especially if we run the simulation using GPU. Luckily, we can compile our package using PackageCompiler.jl:","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"using PackageCompiler\ncompile_incremental(:MicroMag)","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"After finishing the compilation, a dyn.so file will be generated. If we start julia using julia -J /path/to/dyn.so the stratup time will be ignorable.","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"Note: If you got an error similar to that shown at https://github.com/JuliaLang/PackageCompiler.jl/issues/184, using dev PackageCompiler may solve the issue.","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"If other errors appear, it is better to figure out which package is failed","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"compile_incremental(:FFTW, :CUDAdrv, :CUDAnative, :CuArrays, force=false)","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"and remove that package from deps in Project.toml. For example, if CuArrays fails, comment the line","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"#CuArrays = \"3a865a2d-5b23-5a0f-bc46-62713ec82fae\"","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"may solve the problem.","category":"page"},{"location":"notes/#LLG-equation-with-Zhang-Li-extension","page":"Notes","title":"LLG equation with Zhang-Li extension","text":"","category":"section"},{"location":"notes/","page":"Notes","title":"Notes","text":"fracpartial vecmpartial t = - gamma vecm times vecH + alpha vecm times  fracpartial vecmpartial t   + u_0 (vecj_s cdot nabla) vecm - beta u_0 vecmtimes (vecj_s cdot nabla)vecm","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"where","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"u_0=fracp g mu_B2 e M_s=fracp g mu_B a^32 e mu_s","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"and mu_B=ehbar(2m) is the Bohr magneton. In LL form","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"(1+alpha^2)fracpartial vecmpartial t = - gamma vecm times vecH - alpha gamma vecm times (vecm times vecH) + (1+alphabeta) u_0 vectau - (beta-alpha) u_0 (vecmtimes vectau)","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"where vectau=(vecj_s cdot nabla)vecm","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"Note that","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"u_0 (vecj_s cdot nabla) vecm=  - u_0 vecmtimesvecmtimes (vecj_s cdot nabla)vecm","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"so this torque is damping-like torque and the last torque is field-like torque. Therefore, we rewrite the LLG equation in the form","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"fracpartial vecmpartial t =\nF(vecm)\ntimes vecm","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"where","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"F(vecm) = frac1(1+alpha^2)\ngamma vecH + u_0 (beta-alpha)vectau+\nfrac1(1+alpha^2)vecm times alpha gamma\n  vecH + u_0 (1+alphabeta) vectau","category":"page"},{"location":"notes/#Cayley-transformation","page":"Notes","title":"Cayley transformation","text":"","category":"section"},{"location":"notes/","page":"Notes","title":"Notes","text":"The LLG equation can be cast into","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"fracpartial vecmpartial t = hatF(vecm) cdot vecm","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"where the operator \\hat{} is defined as","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"hatx = left( beginmatrix\n  0  -x_3  x_2 \n  x_3  0  -x_1 \n  -x_2  x_1  0\n endmatrix right)","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"Using the Cayley transfromation, the LLG equation can be written as","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"fracpartial Omegapartial t = F - frac12 Omega F\n- frac14 Omega F Omega","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"where","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"Omega = hatomega","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"So one has","category":"page"},{"location":"notes/","page":"Notes","title":"Notes","text":"fracpartial vecomegapartial t = vecF - frac12\n(omega times vecF)\n+ frac14 (omega cdot vecF) vecomega","category":"page"},{"location":"functions/#API","page":"API","title":"API","text":"","category":"section"},{"location":"functions/","page":"API","title":"API","text":"CurrentModule = MicroMag","category":"page"},{"location":"functions/#Meshes","page":"API","title":"Meshes","text":"","category":"section"},{"location":"functions/","page":"API","title":"API","text":"FDMesh\nCubicMesh\nTriangularMesh\nCylindricalTubeMesh","category":"page"},{"location":"functions/#MicroMag.FDMesh","page":"API","title":"MicroMag.FDMesh","text":"FDMesh(;dx=1e-9, dy=1e-9, dz=1e-9, nx=1, ny=1, nz=1, pbc=\"open\")\n\nCreate a FDMesh for given parameters. pbc could be any combination of \"x\", \"y\" and \"z\".\n\n\n\n\n\n","category":"type"},{"location":"functions/#MicroMag.CubicMesh","page":"API","title":"MicroMag.CubicMesh","text":"CubicMesh(;dx=1e-9, dy=1e-9, dz=1e-9, nx=1, ny=1, nz=1, pbc=\"open\")\n\nCreate a simple cubic mesh, in which each cell is only connected to six nearest neighbors  and forming a simple cube structure.\n\n\n\n\n\n","category":"type"},{"location":"functions/#MicroMag.TriangularMesh","page":"API","title":"MicroMag.TriangularMesh","text":"TriangularMesh(; dx=1e-9, nx=1, ny=1, pbc=\"open\")\n\nCreate a 2d triangular mesh. The index of the nearest neighbours and the next-nearest  neighbours are given as follows:\n\nnearest index location next-nearest index location\n1 right 1 top-right\n2 top-right 2 top\n3 top-left 3 top-left\n4 left 4 bottom-left\n5 bottom-left 5 bottom\n6 bottom-right 6 bottom-right\n\n\n\n\n\n","category":"type"},{"location":"functions/#MicroMag.CylindricalTubeMesh","page":"API","title":"MicroMag.CylindricalTubeMesh","text":"CylindricalTubeMesh(;dz=1e-9, R=20e-9, nz=1, nr=10, pbc=\"open\")\n\nCreate a cylindrical tube mesh along the +z direction. \n\nThe spins are located on the cylindrical tube uniformly, and are indexed as follows:\n\n  id = index(i, 1, k, nr, 1, nz)\n\nwhich means that the spins are labelled in a ring firstly, then nz is the number of rings.   The coordinates of the spins at each ring are given as (R cos(2*pi*(i-1)/nr), R sin(2*pi*(nr-1)/nr)).\n\nThe nearest neighbours are indexed as follows:\n\n|  1      2        3       4            |left   right    bottom   top |\n\n\n\n\n\n","category":"type"},{"location":"functions/#Shapes","page":"API","title":"Shapes","text":"","category":"section"},{"location":"functions/","page":"API","title":"API","text":"Cylinder\nBox\nTorus","category":"page"},{"location":"functions/#MicroMag.Cylinder","page":"API","title":"MicroMag.Cylinder","text":"Cylinder(;center = (0.0, 0.0, 0.0), radius = 1.0, height= Inf, normal = (0.0, 0.0, 1.0))\n\nCreate a Cylinder shape. \n\n\n\n\n\n","category":"type"},{"location":"functions/#MicroMag.Box","page":"API","title":"MicroMag.Box","text":"Box(;center::Tuple=(0.0, 0.0, 0.0), sides::Tuple=(1.0,1.0,1.0), theta=0.0)\n\nCreate a Box shape.\n\n\n\n\n\n","category":"type"},{"location":"functions/#MicroMag.Torus","page":"API","title":"MicroMag.Torus","text":"Torus(; center::Tuple=(0.0, 0.0, 0.0), R=1.0, r=0.2)\n\nCreate a Torus shape.\n\n\n\n\n\n","category":"type"},{"location":"functions/#Interfaces","page":"API","title":"Interfaces","text":"","category":"section"},{"location":"functions/","page":"API","title":"API","text":"set_backend\ncreate_sim\nrun_sim\nSim\nset_Ms\nset_driver\nset_mu_s\ninit_m0\ninit_m0_random\ninit_m0_skyrmion\nadd_exch\nadd_anis\nadd_cubic_anis\nadd_dmi\nadd_demag\nadd_zeeman\n#add_exch_vector\n#add_exch_kagome\n#add_anis_kagome\n#add_magnetoelectric_laser\n#add_exch_anis\n#add_exch_rkky\n#add_dmi_interlayer\nupdate_zeeman\nupdate_anis\nrelax\n#compute_guiding_center","category":"page"},{"location":"functions/#MicroMag.set_backend","page":"API","title":"MicroMag.set_backend","text":"set_backend(backend=\"cuda\")\n\nSet the backend of MicroMag. Options, hardwares and the corresponding backends are shown as follows: \n\nOption Hardware Backend\n\"cpu\" CPU KernelAbstractions.CPU()\n\"cuda\" or \"nvidia\" NVIDIA GPU CUDA.CUDABackend()\n\"amd\"  or \"roc\" AMD GPU AMDGPU.ROCBackend()\n\"oneAPI\" or \"intel\" Intel GPU oneAPI.oneAPIBackend()\n\"metal\"  or \"apple\" Apple GPU Metal.MetalBackend()\n\n\n\n\n\n","category":"function"},{"location":"functions/#MicroMag.create_sim","page":"API","title":"MicroMag.create_sim","text":"create_sim(mesh; args...)\n\nCreate a micromagnetic simulation instance with given arguments. \n\nmesh: a mesh has to be provided to start the simulation. The mesh could be FDMesh, CubicMesh, or TriangularMesh.\n\nArguments\n\nname : the simulation name, should be a string.\ndriver : the driver name, should be a string. By default, the driver is \"SD\".\nalpha : the Gilbert damping in the LLG equation, should be a number.\nbeta : the nonadiabatic strength in the LLG equation with spin transfer torques (zhang-li model), should be a number.\ngamma : the gyromagnetic ratio, default value = 2.21e5.\nux, uy or uz: the strengths of the spin transfer torque.\nufun : the time-dependent function for u. \nMs: the saturation magnetization, should be NumberOrArrayOrFunction. By default, Ms=8e5\nmu_s: the magnetic moment, should be NumberOrArrayOrFunction. By default, mus=2*muB\nA or J: the exchange constant, should be NumberOrArrayOrFunction.\nD : the DMI constant, should be NumberOrArrayOrFunction.\ndmi_type : the type of DMI, could be \"bulk\" or \"interfacial\".\nKu: the anisotropy constant, should be NumberOrArrayOrFunction.\naxis: the anisotropy axis, should be a tuple, such as (0,0, 1)\ndemag : include demagnetization or not, should be a boolean, i.e., true or false. By default,  demag=false.\nH: the external field, should be a tuple or function, i.e., TupleOrArrayOrFunction. \nm0 : the initial magnetization, should be a tuple or function, i.e., TupleOrArrayOrFunction. \nT : the temperature, should be should be NumberOrArrayOrFunction.\nshape : the shape defines the geometry of the sample, where parameters are configured.\n\n\n\n\n\n","category":"function"},{"location":"functions/#MicroMag.run_sim","page":"API","title":"MicroMag.run_sim","text":"run_sim(sim::AbstractSim; steps=10, dt=1e-12, save_data=true, save_m_every=1, saver=nothing)\n\nRun the simulation to the time steps*dt.\n\nsteps : the total steps of the simulation\ndt: the time interval of each step, so the total simulation time issteps*dt`\nsave_data : saving the overall data such as energies and average magnetization of the simulation at each step\nsave_m_every : save magnetization for every save_m_every step, a negative savemevery will disable the magnetization saving.\nsaver : a saver struct, by default it will use sim's saver. But you can use customized saver instead. For example, if we want to compute the guiding\n\ncenter and save it to a text file, we can define the following saver\n\n    customized_saver = init_saver(\"output.txt\", \"LLG\")\n    push!(custom_saver.items, SaverItem(\"center\", \"m\", compute_guiding_center))\n    run_sim(sim, saver=customized_saver)\n\n\n\n\n\n","category":"function"},{"location":"functions/#MicroMag.Sim","page":"API","title":"MicroMag.Sim","text":"Sim(mesh::Mesh; driver=\"LLG\", name=\"dyn\", integrator=\"DormandPrince\")\n\nCreate a simulation instance for given mesh.\n\n\n\n\n\n","category":"function"},{"location":"functions/#MicroMag.set_Ms","page":"API","title":"MicroMag.set_Ms","text":"set_Ms(sim::MicroSim, Ms::NumberOrArrayOrFunction)\n\nSet the saturation magnetization Ms of the studied system. For example,\n\n   set_Ms(sim, 8.6e5)\n\nor\n\nfunction circular_Ms(i,j,k,dx,dy,dz)\n    if (i-50.5)^2 + (j-50.5)^2 <= 50^2\n        return 8.6e5\n    end\n    return 0.0\nend\nset_Ms(sim, circular_Ms)\n\n\n\n\n\nset_Ms(sim::AbstractSim, geo::Shape, Ms::Number)\n\nSet the saturation magnetization Ms within the Shape.\n\n\n\n\n\n","category":"function"},{"location":"functions/#MicroMag.set_driver","page":"API","title":"MicroMag.set_driver","text":"set_driver(sim::AbstractSim, args::Dict)\n\nSet the driver of the simulation. This function is not intended for users but for developers.\n\n\n\n\n\nset_driver(sim::AbstractSim; driver=\"LLG\", integrator=\"DormandPrince\", args...)\n\nSet the driver of the simulation, can be used to switch the driver.\n\n\n\n\n\n","category":"function"},{"location":"functions/#MicroMag.set_mu_s","page":"API","title":"MicroMag.set_mu_s","text":"set_mu_s(sim::AtomisticSim, Ms::NumberOrArrayOrFunction)\n\nSet magnetic moment mu_s of the studied system. For example,\n\n   set_mu_s(sim, 2*mu_B)\n\nor\n\nfunction circular_shape(i,j,k,dx,dy,dz)\n    if (i-50.5)^2 + (j-50.5)^2 <= 50^2\n        return 2*mu_B\n    end\n    return 0.0\nend\nset_mu_s(sim, circular_shape)\n\n\n\n\n\n","category":"function"},{"location":"functions/#MicroMag.init_m0","page":"API","title":"MicroMag.init_m0","text":"init_m0(sim::MicroSim, m0::TupleOrArrayOrFunction; norm=true)\n\nSet the initial magnetization of the system. If norm=false the magnetization array will be not normalised. Examples:\n\n   init_m0(sim, (1,1,1))\n\nor\n\n   init_m0(sim, (1,1,1), norm=false)\n\nor\n\n   function uniform_m0(i,j,k,dx,dy,dz)\n       return (0,0,1)\n   end\n   init_m0(sim, uniform_m0)\n\n\n\n\n\n","category":"function"},{"location":"functions/#MicroMag.init_m0_random","page":"API","title":"MicroMag.init_m0_random","text":"init_m0_random(sim::MicroSim)\n\nSet the initial magnetization with random direction.\n\n\n\n\n\n","category":"function"},{"location":"functions/#MicroMag.init_m0_skyrmion","page":"API","title":"MicroMag.init_m0_skyrmion","text":"init_m0_skyrmion(sim::AbstractSim, center::Tuple, R::Float64; ratio=0.7, p=-1, c=1, type=\"B\")\n\nSet the magnetization with skyrmions. Note that this function can be called mulitple times to add more skyrmons.\n\ncenter :  the skyrmion center, should be a Tuple. For example, center = (50e-9,50e-9)\n\nR : the skyrmion radius.\n\nratio : ratio=w/R where w is the width of domain wall. By default ratio = 0.7\n\np : polarity, +1 –> core up; -1 –> core down\n\nc : chirality, +1 –> lefthand,for positive D; -1 –> righthand,for negative D\n\ntype : \"B\" or \"N\", representing Bloch or Neel skyrmions.\n\nFor example:\n\n    init_m0_skyrmion(sim, (50e-9,50e-9), 2e-8, ratio=0.5, p=-1, c=1, type=\"B\")\n\n\n\n\n\n","category":"function"},{"location":"functions/#MicroMag.add_exch","page":"API","title":"MicroMag.add_exch","text":"add_exch(sim::MicroSim, A::NumberOrTupleOrArrayOrFunction; name=\"exch\")\n\nAdd exchange energy to the system. The exchange energy is definded as \n\n  E_mathrmex = int_V A (nabla mathbfm)^2 mathrmdV\n\nExamples:\n\n    add_exch(sim, 1e-11)\n\nor \n\n    add_exch(sim, (2e-12,5e-12,0))\n\nor\n\n    function spatial_A(i,j,k,dx,dy,dz)\n        if i<10\n            return 1e-11\n        else\n            return 2e-11\n        end\n    end\n    add_exch(sim, spatial_A)\n\n\n\n\n\nadd_exch(sim::AbstractSim, geo::Shape, A::Number; name=\"exch\")\n\nAdd exchange interaction within the Shape, or update corresponding A if other exch is added.\n\n\n\n\n\nadd_exch(sim::AtomisticSim, J::NumberOrArray; name=\"exch\")\n\nAdd exchange energy to the system. The length of J should be equal to the length of neigbours.\n\n\n\n\n\n","category":"function"},{"location":"functions/#MicroMag.add_anis","page":"API","title":"MicroMag.add_anis","text":"add_anis(sim::AbstractSim, Ku::NumberOrArrayOrFunction; axis=(0,0,1), name=\"anis\")\n\nAdd Anisotropy to the system, where the energy density is given by\n\n    E_mathrmanis =  K_u (1 - vecm cdot hatu)^2\n\n\n\n\n\n","category":"function"},{"location":"functions/#MicroMag.add_cubic_anis","page":"API","title":"MicroMag.add_cubic_anis","text":"add_cubic_anis(sim::AbstractSim, Kc::Float64; axis1=(1,0,0), axis2=(0,1,0), name=\"cubic\")\n\nadd a cubic anisotropy with default axis (1,0,0) , (0,1,0), and (0,0,1). The third axis is defined as axis3 = axis1 x axis2.\n\n  E_mathrmcubic = -int_V K_c (m_x^4 + m_y^4 + m_z^4)  dV\n\nExample\n\n    add_cubic_anis(sim, 1e3, (1, 1, 0), (1, -1, 0))\n\n\n\n\n\n","category":"function"},{"location":"functions/#MicroMag.add_dmi","page":"API","title":"MicroMag.add_dmi","text":"add_dmi(sim::MicroSim, D::NumberOrTupleOrArrayOrFunction; name=\"dmi\", type=\"bulk\")\n\nAdd DMI to the system. type could be \"bulk\", \"interfacial\" or \"D2d\". \n\nExamples:\n\n   add_dmi(sim, 1e-3, type=\"interfacial\")\n\nor\n\n   add_dmi(sim, 1e-3, type=\"D2d\")\n\n   add_dmi(sim, (1e-3, 1e-3, 0), type=\"bulk\")\n\n\n\n\n\nadd_dmi(sim::AtomisticSim, D::Real; name=\"dmi\", type=\"bulk\")\n\nAdd bulk dmi energy to the system. The DMI is defined as\n\nmathcalH_mathrmdmi = sum_langle i jrangle  mathbfD_i j cdotleft(mathbfm_i times mathbfm_jright)\n\nwhere mathbfD_i j is the DM vector. For the bulk dmi mathbfD_i j = D hatr_ij and for interfacial dmi  mathbfD_i j = D hatr_ij times hatz\n\n\n\n\n\n","category":"function"},{"location":"functions/#MicroMag.add_demag","page":"API","title":"MicroMag.add_demag","text":"add_demag(sim::MicroSim; name=\"demag\", Nx=0, Ny=0, Nz=0)\n\nAdd Demag to the system. Nx, Ny and Nz can be used to describe the macro boundary conditions which means that the given mesh is repeated 2Nx+1, 2Ny+1 and2Nz+1times inx,yandz` direction, respectively.\n\n\n\n\n\nadd_demag(sim::AtomisticSim; name=\"demag\", Nx=0, Ny=0, Nz=0 )\n\nadd dipolar interaction into the system.\n\nmathcalH_mathrmd=-fracmu_0 mu_s^24 pi sum_ij frac3left(mathbfm_i cdot hatmathbfr_i jright)left(mathbfm_j cdot hatmathbfr_i jright)-mathbfm_i cdot mathbfm_jr_i j^3\n\n\n\n\n\n","category":"function"},{"location":"functions/#MicroMag.add_zeeman","page":"API","title":"MicroMag.add_zeeman","text":"add_zeeman(sim::AbstractSim, H0::TupleOrArrayOrFunction; name=\"zeeman\")\n\nAdd a static Zeeman energy to the simulation.\n\n\n\n\n\nadd_zeeman(sim::AbstractSim, H0::TupleOrArrayOrFunction, ft::Function; name=\"timezeeman\")\n\nAdd a time varying zeeman to system.\n\nThe input ft is a function of time t and its return value should be a tuple with length 3.\n\nExample:\n\n  function time_fun(t)\n    w = 2*pi*2.0e9\n    return (sin(w*t), cos(w*t), 0)\n  end\n\n  function spatial_H(i, j, k, dx, dy, dz)\n    H = 1e3\n    if i<=2\n        return (H, H, 0)\n    end\n    return (0, 0, 0)\n  end\n\n  add_zeeman(sim, spatial_H, time_fun)\n\n\n\n\n\n","category":"function"},{"location":"functions/#MicroMag.update_zeeman","page":"API","title":"MicroMag.update_zeeman","text":"update_zeeman(sim::AbstractSim, H0::TupleOrArrayOrFunction; name=\"zeeman\")\n\nSet the Zeeman field to H0 where H0 is TupleOrArrayOrFunction according to its name. For example,\n\n   add_zeeman(sim, (0,0,0), name=\"my_H\")  #create a zeeman energy with field (0,0,0) A/m\n   update_zeeman(sim, (0,0,1e5), name=\"my_H\")  #change the field to (0,0,1e5) A/m\n\n\n\n\n\n","category":"function"},{"location":"functions/#MicroMag.update_anis","page":"API","title":"MicroMag.update_anis","text":"update_anis(sim::MicroSim, Ku::NumberOrArrayOrFunction; name = \"anis\")\n\nupdate anisotropy constant Ku according to its name.\n\nExample:\n\n    mesh = FDMesh(nx=200, ny=200, nz=12, dx=5e-9, dy=5e-9, dz=5e-9)\n    sim = Sim(mesh)\n    add_anis(sim, 3e4, axis = (0,0,1), name=\"K1\")\n    add_anis(sim, 1e5, axis = (1,0,0), name=\"K2\")\n    update_anis(sim, 5e4, name=\"K2\")  #update anisotropy K2\n\n\n\n\n\n","category":"function"},{"location":"functions/#MicroMag.relax","page":"API","title":"MicroMag.relax","text":"relax(sim::AbstractSim; maxsteps=10000, stopping_dmdt=0.01, save_data_every=1, save_m_every=-1, using_time_factor=true)\n\nRelax the system using LLG or SD driver. This function works for both micromagnetic and atomistic simulations.\n\nmaxsteps is the maximum steps allowed to run. \n\nstopping_dmdt is the main stop condition, both for both for LLG and SD drivers. For standard micromagnetic simulaition,  the typical value of stopping_dmdt is in the range of [0.01, 1].  In the SD driver, the time is not strictly defined.  To make it comparable for the LLG driver, we multiply a factor of gamma. However, for the atomistic model  with dimensionless unit, this factor should not be used. In this situation, using_time_factor should be set to false.\n\nsave_data_every set the step for overall data saving such as energies and average magnetization. A negative save_data_every will disable the data saving (save_data_every=-1 will enable the data saving at the end of relaxing).\n\nsave_m_every set the step for magnetization saving, a negative save_m_every will disable the magnetization saving.\n\nExamples:\n\n    relax(sim, maxsteps=10000, stopping_dmdt=0.1)\n\n\n\n\n\n","category":"function"},{"location":"functions/#DataSaving","page":"API","title":"DataSaving","text":"","category":"section"},{"location":"functions/","page":"API","title":"API","text":"#save_m\nsave_vtk\nsave_ovf\nread_ovf","category":"page"},{"location":"functions/#MicroMag.save_vtk","page":"API","title":"MicroMag.save_vtk","text":"save_vtk(mesh::Mesh, shape::Union{CSGNode,Shape}, fname::String)\n\nSave the shape to vtk. \n\n    mesh = FDMesh(dx=2e-9, dy=2e-9, dz=2e-9, nx=100, ny=100, nz=50)\n    t1 = Torus(R = 60e-9, r=20e-9)\n    save_vtk(mesh, t1, \"torus\")\n\n\n\n\n\nsave_vtk(sim::AbstractSim, fname::String; fields::Array{String, 1} = String[])\n\nSave magnetization or other fields to vtk.\n\n    save_vtk(sim, \"m\")\n\n\n\n\n\n","category":"function"},{"location":"functions/#MicroMag.save_ovf","page":"API","title":"MicroMag.save_ovf","text":"save_ovf(sim::AbstractSim, fname::String; type::DataType = Float64)\n\nSave spins by ovf, which can be viewed by Muview. \n\nParameters:\n\nSim : Sim struct whose spin to be saved.\n\nfname : Save file name.\n\nOptional:\n\ntype : Data type of ovf2 file. Can be chosen from Float32, Float64 or String.\n\nFor example:\n\n```julia\n    save_ovf(sim, \"ovf_example\")\n```\n\nOr to specify a certain data type:\n\n```julia\n    save_ovf(sim, \"ovf_example\", type = String)\n```\n\n\n\n\n\n","category":"function"},{"location":"functions/#MicroMag.read_ovf","page":"API","title":"MicroMag.read_ovf","text":"read_ovf(sim, fname)\n\nInitialize sim with an ovf file named of \"fname.ovf\".\n\n\n\n\n\nread_ovf(fname)\n\nLoad ovf file as OVF2 Type, where spin is stored in OVF2.data\n\n\n\n\n\n","category":"function"},{"location":"functions/#Tools","page":"API","title":"Tools","text":"","category":"section"},{"location":"functions/","page":"API","title":"API","text":"ovf2vtk\n#plot_m\n#jdl2png\n#jdl2movie","category":"page"},{"location":"functions/#MicroMag.ovf2vtk","page":"API","title":"MicroMag.ovf2vtk","text":"ovf2vtk(ovf_name, vtk_name=nothing; point_data=false, box=noting)\n\nConvert ovf file to vtk format. The data will be saved to points if point_data == true otherwise the data will be saved to cells.\n\nIf box is not nothing, it should be a tuple. For instance, box = (nx1, nx2, ny1, ny2, nz1, nz2). In this case, the generated vtk only contains the spins inside the box (including the boundary).\n\n    ovf2vtk(\"my.ovf\", \"test.vts\")\n    ovf2vtk(\"my.ovf\", point_data=true)\n\n\n\n\n\n","category":"function"},{"location":"functions/#DataTypes","page":"API","title":"DataTypes","text":"","category":"section"},{"location":"functions/","page":"API","title":"API","text":"MicroMag.NumberOrArrayOrFunction\nMicroMag.NumberOrTupleOrArrayOrFunction\nMicroMag.NumberOrArray\nMicroMag.TupleOrArrayOrFunction","category":"page"},{"location":"functions/#MicroMag.NumberOrArrayOrFunction","page":"API","title":"MicroMag.NumberOrArrayOrFunction","text":"NumberOrArrayOrFunction\n\nIn Micromagnetics, typical parameters such as saturation magnetization Ms and exchange stiffness constant A are constant. However, there are many cases that a spatial Ms is needed. For instance, if the simulated system is a circular disk the Ms in the corners should be set to zero. If the simulated system contains mutiple materials, the exchange constant A should be spatial as well. The Union NumberOrArrayOrFunction is designed to deal with such situations. As indicated from its name, it means that the input parameter could be a number or an array or a function:\n\nNumber: should be Real.\nArray: the length of the array should be N where N is the total spin number of the system.\nFunction: the parameter of the function should be (i,j,k,dx,dy,dz) where i,j,k is the cell index and dx,dy,dz is the cellsize. The return value of the function should be a real number. For example,\nfunction circular_Ms(i,j,k,dx,dy,dz)\n    if (i-50.5)^2 + (j-50.5)^2 <= 50^2\n        return 8.6e5\n    end\n    return 0.0\nend\n\n\n\n\n\n","category":"type"},{"location":"functions/#MicroMag.NumberOrTupleOrArrayOrFunction","page":"API","title":"MicroMag.NumberOrTupleOrArrayOrFunction","text":"NumberOrTupleOrArrayOrFunction\n\nIn micromagnetics, there are also cases where the input parameters can be either scalars or vectors and vary with space. For example, the parameters for the DMI could be a const for bulk DMI or interfacial DMI. In some materials, the DMI const may differ in different  directions and thus a tuple with three numbers is required. In MicroMag, the union NumberOrTupleOrArrayOrFunction is designed to deal  with such situations. Similar to NumberOrArrayOrFunction, NumberOrTupleOrArrayOrFunction means that the input parameter could be  a number, a tuple, an array or a function:\n\nNumber: should be Real.\nTuple: should be Real with length 3. For example, (1,2e-5,0).\nArray: the length of the array should be N or 3N where N is the total spin number of the system.\nFunction: the parameter of the function should be (i,j,k,dx,dy,dz) and the return value should be a tuple with length 3.\nFor example,\nfunction uniform_m0(i,j,k,dx,dy,dz)\n    return (0,0,1)\nend\n\n\n\n\n\n","category":"type"},{"location":"functions/#MicroMag.NumberOrArray","page":"API","title":"MicroMag.NumberOrArray","text":"NumberOrArray\n\nSimilar to Union NumberOrArrayOrFunction, the Union NumberOrArray is designed to deal with cases that a number or an array is needed.\n\n\n\n\n\n","category":"type"},{"location":"functions/#MicroMag.TupleOrArrayOrFunction","page":"API","title":"MicroMag.TupleOrArrayOrFunction","text":"TupleOrArrayOrFunction\n\nSimilar to NumberOrArrayOrFunction, TupleOrArrayOrFunction means that the input parameter could be a tuple or an array or a function:\n\nTuple: should be Real with length 3. For example, (0,0,1e5).\nArray: the length of the array should be 3N where N is the total spin number of the system.\nFunction: the parameter of the function should be (i,j,k,dx,dy,dz) and the return value should be a tuple with length 3. For example,\nfunction uniform_m0(i,j,k,dx,dy,dz)\n    return (0,0,1)\nend\n\n\n\n\n\n","category":"type"},{"location":"functions/#Others","page":"API","title":"Others","text":"","category":"section"},{"location":"functions/","page":"API","title":"API","text":"MicroMag.MicroSim\nMicroMag.AtomisticSim","category":"page"},{"location":"functions/#MicroMag.MicroSim","page":"API","title":"MicroMag.MicroSim","text":"MicroSim{T<:AbstractFloat} <: AbstractSim\n\n\n\n\n\n","category":"type"},{"location":"functions/#MicroMag.AtomisticSim","page":"API","title":"MicroMag.AtomisticSim","text":"AtomisticSim{T<:AbstractFloat} <: AbstractSim\n\n\n\n\n\n","category":"type"},{"location":"equations/#Equations","page":"Equations","title":"Equations","text":"","category":"section"},{"location":"equations/#Atomistic-spin-model","page":"Equations","title":"Atomistic spin model","text":"","category":"section"},{"location":"equations/","page":"Equations","title":"Equations","text":"The basic assumption of the atomistic spin model is that each lattice site is associated with a magnetic moment mu_s. For metal systems with quenched orbital moments, the magnetic moment is mainly related to its spin angular momentum","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"mathbfmu = - g mu_B mathbfS = - hbar  gamma mathbfS","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"where mu_B=e hbar (2m) is the Bohr magneton, e(0) is the electron charge,  gamma=gmu_Bhbar (0)  is the gyromagnetic ratio g=2 is the g-factor.  The LLG equation governs the dynamics of the magnetic moment,  which reads","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"fracpartial mathbfmpartial t = - gamma mathbfm times mathbfH_mathrmeff + alpha mathbfm times  fracpartial mathbfmpartial t","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"where mathbfm is the unit vector of the magnetic moment, mathbfH_mathrmeff is the effective field.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"Unlike the continuous micromagnetic model, the atomistic spin model is discrete, and thus, the effective field mathbfH_mathrmeff is defined as the partial derivative of the total Hamiltonian with respect to mathbfm, i.e., ","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"mathbfH_mathrmeff=-frac1mu_s fracpartial mathcalHpartial mathbfm","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"where mathcalH is the total Hamiltonian including the exchange interaction, Dzyaloshinskii-Moriya interaction, dipolar interaction, anisotropy interaction,  Zeeman interaction and so on.  ","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"The exchange interaction is given by","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"mathcalH_mathrmex = -J sum_langle i jrangle mathbfm_i cdot mathbfm_j","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"where J denotes the exchange constant and langle ij rangle represents a unique pair between lattice sites i and j and we assume that the summation is taken only once for each pair. A positive J results in the ferromagnetic state while a negative J leads to the antiferromagnetic state, which can be seen by minimizing the exchange Hamiltonian. To solve the LLG equation numerically, we need the effective field at each site, which is given ","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"mathbfH_mathrmex i = fracJmu_s sum_langle i jrangle mathbfm_j","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"Similarly, the Dzyaloshinskii-Moriya interaction reads","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"mathcalH_mathrmdmi =  sum_langle i jrangle  mathbfD_i j cdotleft(mathbfm_i times mathbfm_jright)","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"where mathbfD_i j is the DM vector.  Typically, there are two situations: (1) mathbfD_i j = D hatr_ij, which corresponds to the Bulk DMI. (2) mathbfD_i j = D hatr_ij times hatz, which corresponds to the interfacial DMI. Unlike the exchange interaction, the DM Hamiltonian is minimal when the two adjacent magnetic moments are perpendicular. The corresponding effective field can be computed by","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"mathbfH_mathrmdmi i = frac1mu_s sum_langle i jrangle mathbfD_i j times mathbfm_j","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"The other two common interactions are the anisotropy and the Zeeman, which are given by","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"mathcalH_mathrman = - K sum_ileft(mathbfm_i cdot haturight)^2 \nmathcalH_mathrmze =  - mu_s mathbfm_i cdot mathbfH","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"The effective field of the anisotropy is ","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"mathbfH_mathrman i = frac2Kmu_s  (mathbfm_i cdot hatu) hatu","category":"page"},{"location":"equations/#Multiferroic-Insulators","page":"Equations","title":"Multiferroic Insulators","text":"","category":"section"},{"location":"equations/","page":"Equations","title":"Equations","text":"For multiferroics such as Cu_2OSeO_3, the noncollinear spin texture induces a local electric polarization via the the d-p hybridization mechanism. The local electric dipole moment mathbfP depends on the direction of the applied static magnetic field relative to the crystallographic axes.[PRL 128, 037201 (2022)] ","category":"page"},{"location":"equations/#H_0//001:","page":"Equations","title":"H_0001:","text":"","category":"section"},{"location":"equations/","page":"Equations","title":"Equations","text":"mathbfP_i=lambdaleft(-m_i z m_i x m_i y m_i z frac-m_i x^2+m_i y^22right)","category":"page"},{"location":"equations/#H_0//110:","page":"Equations","title":"H_0110:","text":"","category":"section"},{"location":"equations/","page":"Equations","title":"Equations","text":"mathbfP_i=lambdaleft(-m_i x m_i y frac-m_i x^2+m_i z^22 m_i y m_i zright)","category":"page"},{"location":"equations/#H_0//111:","page":"Equations","title":"H_0111:","text":"","category":"section"},{"location":"equations/","page":"Equations","title":"Equations","text":"mathbfP_ix=-lambda fracm_i xleft(sqrt2 m_i y+m_i zright)sqrt3 \n\nmathbfP_iy = lambda frac-m_i x^2+m_i yleft(m_i y-sqrt2 m_i zright)sqrt6 \n\nmathbfP_iz =\n-lambda fracm_i x^2+m_i y^2-2 m_i z^22 sqrt3","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"The Hamiltonian related to the high-frequency lasers is given by ","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"mathcalH_mathrmlaser =  -sum_i mu_s mathbfm_i cdot mathbfH(t) - sum_i mathbfP_i cdot mathbfE(t)","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"The corresponding effective fields associated with the electric field are","category":"page"},{"location":"equations/#H_0//001:-2","page":"Equations","title":"H_0001:","text":"","category":"section"},{"location":"equations/","page":"Equations","title":"Equations","text":"H_x = fraclambdamu_s  (-E_z m_x  - E_x m_z )\nH_y = fraclambdamu_s  (E_z m_y  + E_y m_z )\nH_z = fraclambdamu_s  (-E_x m_x  + E_y m_y )","category":"page"},{"location":"equations/#H_0//110:-2","page":"Equations","title":"H_0110:","text":"","category":"section"},{"location":"equations/","page":"Equations","title":"Equations","text":"H_x = fraclambdamu_s  (-E_y m_x  - E_x m_y )\nH_y = fraclambdamu_s  (-E_x m_x  + E_z m_z )\nH_z = fraclambdamu_s  (E_z m_y  + E_y m_z )","category":"page"},{"location":"equations/#H_0//111:-2","page":"Equations","title":"H_0111:","text":"","category":"section"},{"location":"equations/","page":"Equations","title":"Equations","text":"H_x = -fraclambdasqrt3mu_s  (sqrt2(E_y m_x + E_x m_y)  +E_z m_x + E_x m_z )\nH_y = -fraclambdasqrt3mu_s  (sqrt2(E_x m_x - E_y m_y)  +E_z m_y + E_y m_z )\nH_z = -fraclambdasqrt3mu_s  (E_x m_x  + E_y m_y - 2 E_z m_z)","category":"page"},{"location":"equations/#Micromagnetic-model","page":"Equations","title":"Micromagnetic model","text":"","category":"section"},{"location":"equations/","page":"Equations","title":"Equations","text":"In micromagnetics, the effective field can be computed from the total micromagnetic energy","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"mathbfH_mathrmeff=-frac1mu_0 M_s fracdelta Edelta mathbfm","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"The typical energy terms are","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"Exchange energy","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"  E_mathrmex = int_V A (nabla mathbfm)^2 mathrmdV","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"where (nabla mathbfm)^2=left(nabla m_xright)^2+left(nabla m_yright)^2+left(nabla m_zright)^2. So the corresponding effective field is","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"  mathbfH_mathrmex=frac2 Amu_0 M_s nabla^2 mathbfm","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"Zeeman energy","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"  E_mathrmex = -  mu_0 int_V  mathbfH cdot mathbfM mathrmdV","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"as expected, the effective field is mathbfH.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"Anisotropy\nThe uniaxial anisotropy energy is given by","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"  E_mathrmanis = -int_V K_u (mathbfm cdot hatu)^2  dV","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"from which the effective field can be computed as","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"  mathbfH_mathrman=frac2 K_umu_0 M_sleft(mathbfm cdot haturight) hatu","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"Cubic Anisotropy\nThe cubic anisotropy energy is given by","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"  E_mathrmcubic = -int_V K_c (m_x^4 + m_y^4 + m_z^4)  dV","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"and thus the corresponding effective field reads","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"  mathbfH_mathrmcubic= frac4 K_cmu_0 M_s  \n  left( m_x^3 mathbfe_x + m_y^3 mathbfe_y + m_z^3 mathbfe_z right)","category":"page"},{"location":"equations/#Dzyaloshinskii-Moriya-Energy","page":"Equations","title":"Dzyaloshinskii-Moriya Energy","text":"","category":"section"},{"location":"equations/","page":"Equations","title":"Equations","text":"In the continuum limit, the DMI energy density w_mathrmdmi is associated with the so-called Lifshitz invariants, which are terms in the form","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"L^(k)_ij = m_i fracpartial m_jpartial x_k - m_j fracpartial m_ipartial x_k","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"The form of DMI energy density varies depending on the symmetry class. For bulk DMI, corresponding to symmetry class T or O, the expression is given by: ","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"  w_mathrmdmi = D(L^(z)_yx + L^(y)_xz + L^(x)_zy) = D mathbfm cdot (nabla times mathbfm)","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"The associated effective field is","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"  mathbfH_mathrmdmi=-frac2Dmu_0 M_s (nabla times mathbfm)","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"For a thin film with interfacial DMI or a crystal with symmetry class C_nv, the energy density is","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"  w_mathrmdmi=D (L_x z^(x)+L_y z^(y) )=Dleft(mathbfm cdot boldsymbolnabla m_z-m_z boldsymbolnabla cdot mathbfmright)","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"and the effective field is ","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"  mathbfH_mathrmdmi=-frac2 Dmu_0 M_s (mathbfe_y times fracpartial mathbfmpartial x - mathbfe_x times fracpartial mathbfmpartial y)","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"For a crystal with symmetry class D_2d, the DMI energy density is given by w_mathrmdmi=D (L_x z^(y)+L_y z^(x)), resulting in the effective field","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"  mathbfH_mathrmdmi=-frac2 Dmu_0 M_s (mathbfe_y times fracpartial mathbfmpartial y - mathbfe_x times fracpartial mathbfmpartial x )","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"Although the effective fields for different symmetries differ, the numerical implementation can be unified as follows","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"  mathbfH_mathrmdmi i = -frac1mu_0 M_s sum_j in N_i D_ij fracmathbfe_ij times mathbfm_jDelta_i j","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"where D_ij represents the effective DMI constant and mathbfe_ij denotes the DMI vectors. For bulk DMI, mathbfe_ij = hatmathbfr_ij where hatmathbfr_ij is the unit vector between cell i and cell j. For interfacial DMI,  mathbfe_ij = mathbfe_z times mathbfhatr_ij, i.e., mathbfe_ij=-mathbfe_y mathbfe_y mathbfe_x -mathbfe_x 0 0  for the 6 neighbors N_i=-x+x-y+y-z +z.  For the symmetry class D_2d one has mathbfe_ij=mathbfe_x -mathbfe_x -mathbfe_y mathbfe_y 0 0. If the cell-based DMI is provided, the effective DMI constant can be computed as","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"  D_i j=frac2 D_i D_jD_i+D_j","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"Bulk DMI energy The Bulk DMI energy reads","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"  E_mathrmdmi = int_V D mathbfm cdot (nabla times mathbfm)  mathrmdV","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"so the effective field is","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"  mathbfH_mathrmD=-frac2 Dmu_0 M_s(nabla times mathbfm)","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"Magnetostatic energy","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"  E_mathrmd=-fracmu_02 int_V mathbfH_mathrmd(mathbfr) cdot mathbfM(mathbfr) d V","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"  mathbfH_mathrmd(mathbfr)=frac14 pileft(int_V rho_mleft(mathbfr^primeright) fracmathbfr-mathbfr^primeleftmathbfr-mathbfr^primeright^3 mathrmd^3 r^prime+int_S sigma_mleft(mathbfr^primeright) fracmathbfr-mathbfr^primeleftmathbfr-mathbfr^primeright^3 mathrmd^2 r^primeright)","category":"page"},{"location":"equations/#LLG-equation","page":"Equations","title":"LLG equation","text":"","category":"section"},{"location":"equations/","page":"Equations","title":"Equations","text":"The driver LLG solves the standard LLG equation, which can be written as","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"fracpartial mathbfmpartial t = - gamma mathbfm times mathbfH + alpha mathbfm times  fracpartial mathbfmpartial t","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"and the corresponding LL form is given by","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"(1+alpha^2)fracpartial mathbfmpartial t = - gamma mathbfm times mathbfH - alpha gamma mathbfm times (mathbfm times mathbfH)","category":"page"},{"location":"equations/#LLG-equation-with-extensions","page":"Equations","title":"LLG equation with extensions","text":"","category":"section"},{"location":"equations/#Spin-transfer-torque","page":"Equations","title":"Spin transfer torque","text":"","category":"section"},{"location":"equations/","page":"Equations","title":"Equations","text":"In micromagnetics, the spin transfer torque is modelled with the extended LLG equation Zhang-Li extension,  which reads","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"fracpartial mathbfmpartial t = - gamma mathbfm times mathbfH + alpha mathbfm times  fracpartial mathbfmpartial t\n+ (mathbfu cdot nabla) mathbfm - beta mathbfmtimes (mathbfu cdot nabla)mathbfm","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"where ","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"mathbfu = fracp g mu_B2 e M_s mathbfj","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"represents the strength of the current. The unit of mathbfu is m/s.  In the definition of  mathbfu, p is the spin polarization of the electric current, e(0) is the elementary charge, M_s is the saturation magnetization and mathbfj is electric current density.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"For the atomistic model, ","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"mathbfu = fracp g mu_B a^32 e mu_s mathbfj = fracp a^32 e S mathbfj","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"where S = mathbfS is the length of local spin.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"In MicroMag, the the extended LLG equation Zhang-Li extension is implemented in the driver LLG_STT.   Moreover, the driver LLG_CPP implements the LLG equation with spin transfer torque for the current-perpendicular-to-plane (CPP) case,","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"fracpartial mathbfmpartial t = - gamma mathbfm times mathbfH + alpha mathbfm times  fracpartial mathbfmpartial t - a_J mathbfm times (mathbfm times mathbfp)\n -  b_J mathbfm times mathbfp","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"The spin valve structures and  spin orbit torques can use the LLG_CPP driver.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"The driver LLG_STT_CPP has put them together,","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"fracpartial mathbfmpartial t = - gamma mathbfm times mathbfH + alpha mathbfm times  fracpartial mathbfmpartial t\n+ (mathbfu cdot nabla) mathbfm - beta mathbfmtimes (mathbfu cdot nabla)mathbfm - a_J mathbfm times (mathbfm times mathbfp)\n -  b_J mathbfm times mathbfp","category":"page"},{"location":"equations/#SLLG-equation","page":"Equations","title":"SLLG equation","text":"","category":"section"},{"location":"equations/","page":"Equations","title":"Equations","text":"The SLLG equation, i.e., LLG equation including the stochastic field mathbfb, is given by","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"fracpartial mathbfmpartial t = - gamma mathbfm times (mathbfH_mathrmeff +mathbfb) + alpha mathbfm times  fracpartial mathbfmpartial t","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"The thermal fluctuation is assumed to be a Gaussian white noise, i.e., the thermal noise mathbfb obeys the  properties","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"left mathbfb right = 0  left mathbfb_i^u cdot mathbfb_j^v right = 2 D delta_ij delta_uv","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"where i and j are Cartesian indices, u and v indicate the magnetization components and left cdot  cdot right represents the average taken over different realizations of the fluctuating field. And","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"D = fracalpha k_B Tgamma mu_s","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"For the micromagnetic case, D is given as","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"D = fracalpha k_B Tmu_0 M_s gamma Delta V","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"which is equivalent to a stochastic field  ","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"mathbfb^u = eta sqrt frac2 alpha k_B Tmu_0 M_s gamma Delta V dt","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"where eta is a random number follows the normal distribution.","category":"page"},{"location":"equations/#Steepest-descent-method","page":"Equations","title":"Steepest descent method","text":"","category":"section"},{"location":"equations/","page":"Equations","title":"Equations","text":"We provide a steepest descent energy minimization method for a complicated system, which is of the form","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"x_k+1 = x_k + alpha_k d_k","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"where","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"d_k = - nabla f(x_k)","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"And for the micromagnetics, we have","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"mathbfm_k+1 = mathbfm_k - tau_k mathbfm_k  times (mathbfm_k times mathbfH_mathrmeff)","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"In practice, we use the following update rule to keep the magnetization vector normalized.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"boldsymbolm_k+1=boldsymbolm_k-tau_k fracboldsymbolm_k+boldsymbolm_k+12 timesleft(boldsymbolm_k times boldsymbolH_mathrmeffleft(boldsymbolm_kright)right)","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"boldsymbolm_k+1^2 = boldsymbolm_k^2","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"From the equation we have:","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"(1+fractau_k^24 boldsymbolf_k^2)mathbfm_k+1 =\n(1-fractau_k^24 boldsymbolf_k^2)mathbfm_k -  tau_k mathbfg_k","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"where","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"beginaligned\nmathbff_k = mathbfm_k times mathbfH_mathrmeff\nboldsymbolg_k =boldsymbolm_k timesleft(boldsymbolm_k times boldsymbolH_mathrmeffright)\nendaligned","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"The step size tau_k can be computed by","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"tau_k^1=fracsum_i boldsymbols_k-1^i cdot boldsymbols_k-1^isum_i boldsymbols_k-1^i cdot boldsymboly_k-1^i quad quad tau_k^2=fracsum_i boldsymbols_k-1^i cdot boldsymboly_k-1^isum_i boldsymboly_k-1^i cdot boldsymboly_k-1^i","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"where","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"beginaligned  boldsymbols_k-1 =boldsymbolm_k-boldsymbolm_k-1  boldsymboly_k-1 =boldsymbolg_k-boldsymbolg_k-1 endaligned","category":"page"},{"location":"equations/#Monte-Carlo-Simulation","page":"Equations","title":"Monte Carlo Simulation","text":"","category":"section"},{"location":"equations/","page":"Equations","title":"Equations","text":"The implemented energy reads","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"mathcalH = -sum_langle i jrangle left( J_x S_i^x  S_j^x + J_y S_i^y  S_j^y + J_z S_i^z  S_j^z right)\n\n+ sum_langle i jrangle  mathbfD_i j cdotleft(mathbfS_i times mathbfS_jright)\n\n- K sum_ileft(mathbfu cdot mathbfS_iright)^2 - sum_i mathbfH cdot mathbfS_i","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"where mathbfS_i is unit vector of the classical spin at site i.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"For interfacial DMI,","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"mathbfD_i j = D hatz times hatr_ij  + D_z^j hatz","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"while for Bulk DMI, ","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"mathbfD_i j = D hatr_ij","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"Note that the Monte Carlo only works for triangular and cubic meshes.","category":"page"},{"location":"equations/#NEB-(Nudged-elastic-band)","page":"Equations","title":"NEB (Nudged elastic band)","text":"","category":"section"},{"location":"equations/","page":"Equations","title":"Equations","text":"NEB is a chain method to find the MEP (minimum energy path) between two states. To start, we need to construct a chain including several images (each image is a copy of the magnetization) and then relax the system. Two ends images that corresponding to the initial and final states will be pinned as they are the energy states given by the users. The system contain all free images will be relaxed to reduce the total energy, which is very similar to the case that relaxing the magnetic system using LLG equation if one disables the precession term. One significant difference is that the effective field in LLG equation is the functional derivative of the system energy with respect to magnetization while in NEB the effective field of image n should also contain the influence of its neighbours (i.e., the images n-1 and n+1). This influence is described by the so-called tangents: only the perpendicaular part of the effective field is kept when relaxing the whole system.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"Assume that the whole system has N images","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"mathbfZ = mathbfY_1 mathbfY_2  mathbfY_N","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"where","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"mathbfY_i = m_1x m_1y m_1z  m_nx m_ny m_nz","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"each image has n spins. To relax the system, we could solve the equation","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"fracmathbfY_ipartial t = - mathbfY_i times (mathbfY_i times mathbfG_i)","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"where mathbfG_i is effective field that can be computed as","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"mathbfY_i = mathbfH_i - (mathbfH_i cdot mathbft_i) mathbft_i +  mathbfF_i","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"The mathbfH_i is the normal micromagnetic effective field, mathbft_i is the tangent and mathbfF_i is a force that can be used to adjust the distance between images.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":" mathbfF_i = k (mathbfY_i+1-mathbfY_i-mathbfY_i-mathbfY_i-1) mathbft_i","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"The distance bewteen images mathbfY_i and mathbfY_j is defined as","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":" L = left  sum_k (L_k^ij)^2 right  ^12","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"where L_k^ij is the geodesic distance of point k that can be computed using Vincenty's formula.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"The tangents can be computed as follows","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"mathbft_i^+ =  mathbfY_i+1-mathbfY_i\nmathbft_i^- =  mathbfY_i-mathbfY_i-1","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"The detailed equations can be found @ [Journal of Chemical Physics 113, 22 (2000)] and [Computer Physics Communications 196 (2015) 335–347].","category":"page"},{"location":"developer/#Developers","page":"Developers","title":"Developers","text":"","category":"section"},{"location":"developer/","page":"Developers","title":"Developers","text":"To develop MicroMag, simply using","category":"page"},{"location":"developer/","page":"Developers","title":"Developers","text":"(@v1.7) pkg> dev MicroMag","category":"page"},{"location":"developer/","page":"Developers","title":"Developers","text":"in the Julia REPL. The folder $JULIA_DEPOT_PATH/dev/MicroMag should be created and you can modifiy the codes in it.  For example, we could open the file src/MicroMag.jl and add a function dev_test ","category":"page"},{"location":"developer/","page":"Developers","title":"Developers","text":"function dev_test()\n    return \"This is a newly added function!\"\nend","category":"page"},{"location":"developer/","page":"Developers","title":"Developers","text":"We can check it in a new Julia REPL:","category":"page"},{"location":"developer/","page":"Developers","title":"Developers","text":"julia> using MicroMag\n[ Info: Precompiling MicroMag [8b6b6816-cea2-582c-a99f-83810c20db0f]\n\njulia> MicroMag.dev_test()\n\"This is a newly added function!\"","category":"page"},{"location":"developer/","page":"Developers","title":"Developers","text":"After the modification, we can push our codes into github using ","category":"page"},{"location":"developer/","page":"Developers","title":"Developers","text":"git commit -m \"we added a dev function\" -a\ngit push","category":"page"},{"location":"basics/#Basics","page":"Basics","title":"Basics","text":"","category":"section"},{"location":"basics/#Meshes","page":"Basics","title":"Meshes","text":"","category":"section"},{"location":"basics/","page":"Basics","title":"Basics","text":"MicroMag uses finite difference methods to discretize the micromagnetic energies. In MicroMag, the discretized grid information  is stored in FDMesh. Therefore, before starting the simulation, we need to create a mesh.","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"mesh = FDMesh(;dx=1e-9, dy=1e-9, dz=1e-9, nx=1, ny=1, nz=1)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"In fact, FDMesh is used in our micromagnetic simulations, while for atomic models, we can use CubicMesh, TriangularMesh, as well as CylindricalTubeMesh, etc.","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"<div class=\"mermaid\">\ngraph LR;\n    Mesh --> FDMesh\n    Mesh --> AtomisticMesh\n    AtomisticMesh --> TriangularMesh\n    AtomisticMesh --> SquareMesh\n    AtomisticMesh --> CubicMesh\n    AtomisticMesh --> CylindricalTubeMesh\n</div>","category":"page"},{"location":"basics/#Sim","page":"Basics","title":"Sim","text":"","category":"section"},{"location":"basics/","page":"Basics","title":"Basics","text":"In MicroMag, we can create different Sim objects based on the computational system or problem type. MicroMag defines four types of Sims:","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"<div class=\"mermaid\">\ngraph LR\n   AbstractSim --> MicroSim\n   AbstractSim --> AtomisticSim\n   AbstractSim --> NEB\n   AbstractSim --> MonteCarlo\n</div>","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"For MicroSim and AtomisticSim, we recommend using the create_sim function to create them, as the create_sim function  can specify some parameters while creating Sim. Of course, these parameters can also be specified later. ","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"sim = create_sim(mesh)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Note: all simulation data can be obtained through sim, especially, we can obtain the magnetization distribution state of the system through sim.spin at any time.","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"note: Note\nBy default, the magnetization is stored in a 1D array with the form m_1x m_1 y m_1 z  m_nx m_n y m_n z, which can be reshaped into a 4D arraym = reshape(sim.spin, 3, nx, ny, nz)\nmx = m[1, :, :, :]\nmy = m[2, :, :, :]\nmz = m[3, :, :, :]","category":"page"},{"location":"basics/#Functions","page":"Basics","title":"Functions","text":"","category":"section"},{"location":"basics/","page":"Basics","title":"Basics","text":"In MicroMag, all parameters can be set using functions. For example, we can use the set_Ms function to set the saturation magnetization of the system. Of course, Ms should be a scalar for the same material, and we can set it like this:","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"set_Ms(sim, 8.6e5)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Additionally, we can set it with a function, like this:","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"function circular_Ms(i,j,k,dx,dy,dz)\n    if (i-50.5)^2 + (j-50.5)^2 <= 50^2\n        return 8.6e5\n    end\n    return 0.0\nend\nset_Ms(sim, circular_Ms)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Note that the Mesh we create is actually a regular cuboid, but in reality, the shape of the sample is not necessarily a cuboid. At this time, we define a round disk,  where its Ms is 0 outside the disk. In this way, we can define the shape of the simulation system. Please note that in MicroMag, almost all setting functions can  accept a function as input. This cell-based approach maximizes flexibility, allowing for defining shapes, defining multiple materials, etc.","category":"page"},{"location":"basics/#Shapes","page":"Basics","title":"Shapes","text":"","category":"section"},{"location":"basics/#Basic-Shapes","page":"Basics","title":"Basic Shapes","text":"","category":"section"},{"location":"basics/","page":"Basics","title":"Basics","text":"In addition to using functions to define shapes, for some regular shapes and their combinations, we can use basic shapes and boolean operations defined in MicroMag to achieve this. MicroMag supports Plane, Cylinder, Sphere, Box, and Torus, etc., as basic shapes.","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"note: Note\noperator Boolean operation\n+ Union\n- Difference\n* Intersection","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Example:","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"using MicroMag\n\nmesh = FDMesh(dx=2e-9, dy=2e-9, dz=2e-9, nx=100, ny=100, nz=50)\n\np1 = Plane(point=(40e-9,0,0), normal=(1, 0, 0))\nsave_vtk(mesh, p1, \"shape1\")\n\nc1 = Cylinder(radius=30e-9, normal=(0.3,0,1))\nsave_vtk(mesh, c1, \"shape2\")\n\ns1 = Sphere(radius = 30e-9, center=(50e-9, 0, 0))\nsave_vtk(mesh, s1, \"shape3\")\n\nb1 = Box(sides = (110e-9, 50e-9, Inf), theta=pi/4)\nsave_vtk(mesh, b1, \"shape4\")\n\nt1 = Torus(R = 60e-9, r=20e-9)\nsave_vtk(mesh, t1, \"shape5\")\n\nt2 = t1 - b1 \nsave_vtk(mesh, t2, \"shape6\")\n\nt3 = t1 * b1 \nsave_vtk(mesh, t3, \"shape7\")\n\nt4 = t1 - p1 + (s1 * p1)\nsave_vtk(mesh, t4, \"shape8\")","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"The saved vts files can be visualized using programs such as Paraview, as shown below:","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"(Image: shapes)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"The created shapes can be used to set parameters, such as","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"set_Ms(sim::AbstractSim, geo::Shape, Ms::Number)","category":"page"},{"location":"basics/#Custom-Shapes","page":"Basics","title":"Custom Shapes","text":"","category":"section"},{"location":"basics/","page":"Basics","title":"Basics","text":"We can also define custom shapes using the create_shape function. Custom shapes can also be combined with basic shapes using boolean operations.","category":"page"},{"location":"basics/#Energy-Terms","page":"Basics","title":"Energy Terms","text":"","category":"section"},{"location":"basics/","page":"Basics","title":"Basics","text":"After creating Sim, we can call functions to add energy terms that need to be considered in the simulation. For example, addzeeman, addexch, adddmi, adddemag  correspondingly add Zeeman energy, exchange interaction energy, DMI, and demagnetization energy.","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Note","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"sim = create_sim(mesh, Ms=8e5, A=1.3e-11)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"and","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"sim = create_sim(mesh)\nset_Ms(sim, Ms=8e5)\n\nex = add_exch(sim, A=1.3e-11)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"are equivalent. The advantage of the latter is that when we need exchange interaction data, we can directly access it through  ex.","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"MicroMag implements energy terms ","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"<div class=\"mermaid\">\ngraph TD;\n    MicroEnergy --> Exchange\n    Exchange --> UniformExchange\n    Exchange --> SpatialExchange\n    Exchange --> ExchangeRKKY\n    MicroEnergy --> BulkDMI\n    MicroEnergy --> SpatialBulkDMI\n    MicroEnergy --> Zeeman\n    MicroEnergy --> Anisotropy\n    MicroEnergy --> CubicAnisotropy\n    MicroEnergy --> StochasticField    \n</div>","category":"page"},{"location":"basics/#Driver","page":"Basics","title":"Driver","text":"","category":"section"},{"location":"basics/","page":"Basics","title":"Basics","text":"<div class=\"mermaid\">\ngraph LR;\n    Driver --> LLG\n    Driver --> LLG_STT\n    Driver --> EnergyMinimization\n</div>","category":"page"},{"location":"basics/#Periodic-Boundary-conditions","page":"Basics","title":"Periodic Boundary conditions","text":"","category":"section"},{"location":"#MicroMag.jl","page":"Home","title":"MicroMag.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for classical spin dynamics and micromagnetic simulations with GPU support.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Supports classical spin dynamics and micromagnetic simulations.\nCompatible with CPU and multiple GPU platforms, including NVIDIA, AMD, Intel, and Apple GPUs.\nSupports both double and single precision.\nSupports Monte Carlo simulations for atomistic models.\nImplements the Nudged-Elastic-Band method for energy barrier computations.\nSupports Spin-transfer torques, including Zhang-Li and Slonczewski models.\nIncorporates various energy terms and thermal fluctuations.\nSupports constructive solid geometry.\nSupports periodic boundary conditions.\nEasily extensible to add new features.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install MicroMag is straightforward as long as Julia (http://julialang.org/downloads/) is installed, and it is equally easy in Windows, Linux and Mac.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"In Julia, packages can be easily installed with the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/ww1g11/MicroMag.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or, equivalently:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg;\njulia> Pkg.add(\"https://github.com/ww1g11/MicroMag.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To enable GPU support, one has to install one of the following packages:","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: GPU Support\nGPU Manufacturer Julia Package\nNVIDIA CUDA.jl\nAMD AMDGPU.jl\nIntel oneAPI.jl\nApple Metal.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example, we can install CUDA for NVIDIA GPUs:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add CUDA","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now we will see similar messages if we type using MicroMag","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using MicroMag\njulia> using CUDA\nPrecompiling CUDAExt\n  1 dependency successfully precompiled in 8 seconds. 383 already precompiled.\n[ Info: Switch the backend to CUDA.CUDAKernels.CUDABackend(false, false)","category":"page"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Assuming we have a cylindrical FeG sample with a diameter of 100 nm and a height of 40 nm, we want to know its magnetization distribution and the stray field around it.  We can use the following script: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using MicroMag\n@using_gpu() #Import available GPU packages such as CUDA, AMDGPU, oneAPI or Metal\n\n# Create a cylindrical shape with a diameter of 100 nm and a height of 40 nm\ngeo = Cylinder(radius=50e-9, height=40e-9) \n\n# Create a finite difference mesh to trigger the simulation\nmesh = FDMesh(nx=80, ny=80, nz=30, dx=2e-9, dy=2e-9, dz=2e-9) \n\n# Create a Sim instance with Fe parameters\nsim = create_sim(mesh, shape=geo, Ms=3.87e5, A = 8.78e-12, D = 1.58e-3, demag=true) \n\ninit_m0_random(sim) #Initialize a random state\n\n#Relax the system to obtain a stable magnetization distribution\nrelax(sim, maxsteps=5000, stopping_dmdt=0.1) \n\n# Save the magnetization and the stray field into vtk.\nsave_vtk(sim, \"m_demag\", fields=[\"demag\"]) ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The magnetization and the stray field around the cylindrical sample are stored in m_demag.vts, which can be opened using Paraview. ","category":"page"},{"location":"#Structure-of-MicroMag","page":"Home","title":"Structure of MicroMag","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<div class=\"mermaid\">\ngraph LR;\n    MicroMag --> Micromagnetic\n    MicroMag --> Atomistic\n    Micromagnetic --> B[Energies: exch, dmi, ...]\n    Atomistic --> B[Energies: exch, dmi, ...]\n    Micromagnetic --> D[Drivers: SD, LLG, STT, SOT]\n    Atomistic --> D[Drivers: SD, LLG, STT, SOT]\n    Micromagnetic --> O[NEB, Eigenvale method]\n    Atomistic --> O[NEB, Eigenvale method]\n    Atomistic --> M[Monte Carlo]\n</div>","category":"page"},{"location":"questions/#Questions","page":"Questions","title":"Questions","text":"","category":"section"},{"location":"questions/#How-the-magnetization-is-stored-in-the-array-spin?","page":"Questions","title":"How the magnetization is stored in the array spin?","text":"","category":"section"},{"location":"questions/","page":"Questions","title":"Questions","text":"In MicroMag, the magnetization is stored in a 1D array with the form m_1x m_1 y m_1 z  m_nx m_n y m_n z","category":"page"},{"location":"questions/#How-to-get-the-global-index-of-magnetization-at-site-(i,j,k)-?","page":"Questions","title":"How to get the global index of magnetization at site (ijk) ?","text":"","category":"section"},{"location":"questions/","page":"Questions","title":"Questions","text":"In MicroMag, the global index can be obtained using the following function","category":"page"},{"location":"questions/","page":"Questions","title":"Questions","text":"function index(i::Int64, j::Int64, k::Int64, nx::Int64, ny::Int64, nz::Int64)\n    if i < 1 || j < 1 || k < 1 || k > nz || j > ny || i > nx\n        return -1\n    end\n    return (k-1) * nx*ny + (j-1) * nx + i\nend","category":"page"},{"location":"questions/#How-to-get-the-effective-field-at-site-(i,j,k)?","page":"Questions","title":"How to get the effective field at site (ijk)?","text":"","category":"section"},{"location":"questions/","page":"Questions","title":"Questions","text":"The effective field is stored in the same form of the magnetization, so the effective at site (i,j,k) can be extracted using","category":"page"},{"location":"questions/","page":"Questions","title":"Questions","text":"  id = index(i,j,k, nx, ny, nz)\n  fx = sim.field[3*id-2]\n  fy = sim.field[3*id-1]\n  fz = sim.field[3*id]","category":"page"},{"location":"questions/","page":"Questions","title":"Questions","text":"Alternatively, we can use reshape function","category":"page"},{"location":"questions/","page":"Questions","title":"Questions","text":"  f = reshape(sim.field, 3, nx, ny, nz)\n  fx,fy,fz = f[:, i,j,k]","category":"page"},{"location":"questions/#How-to-run-MicroMag-in-a-cluster-node-with-multiple-GPUs?","page":"Questions","title":"How to run MicroMag in a cluster node with multiple GPUs?","text":"","category":"section"},{"location":"questions/","page":"Questions","title":"Questions","text":"In the long run, MicroMag will support multiple GPUs. However, here we discuss the common scenario that one needs to change some parameters systematically, such as the geometry size, or cell size, or external field, or charge current as a driving force. In these cases, the simulation can be run in parallel since they are independent tasks. Here is a demo that using 4 GPUs to relax the system with different sizes. ","category":"page"},{"location":"questions/","page":"Questions","title":"Questions","text":"@everywhere using MicroMag\n@everywhere using Printf\n@everywhere using CUDAnative\n\n@everywhere function relax_system(Nx, gpu_id)\n\n  device!(gpu_id)  #using the gpu with gpu_id\n\n  mesh =  FDMeshGPU(nx=Nx, ny=50, nz=1, dx=2.5e-9, dy=2.5e-9, dz=3e-9)\n\n  name = @sprintf(\"Nx_%d\", Nx)\n  sim = Sim(mesh, name=name, driver=\"SD\")\n  set_Ms(sim, 8.0e5)\n  sim.driver.min_tau = 1e-10\n\n  add_exch(sim, 1.3e-11)\n  add_demag(sim)\n\n  init_m0(sim, (1, 0.25, 0.1))\n\n  relax(sim, maxsteps=5000, stopping_torque=1.0)\n\n  return nothing\nend\n\nNx = [i for i in 200:20:400]\nfor i = 1:4:length(Nx)\n    r1 = remotecall(relax_system, 1, Nx[i], 0)\n    r2 = remotecall(relax_system, 2, Nx[i+1], 1)\n    r3 = remotecall(relax_system, 3, Nx[i+2], 2)\n    r4 = remotecall(relax_system, 4, Nx[i+3], 3)\n    fetch(r1)\n    fetch(r2)\n    fetch(r3)\n    fetch(r4)\nend","category":"page"},{"location":"questions/","page":"Questions","title":"Questions","text":"Here is the corresponding Slurm script:","category":"page"},{"location":"questions/","page":"Questions","title":"Questions","text":"#!/bin/bash\n#SBATCH --nodes=1             # Number of nodes\n#SBATCH --ntasks=1            # Number of tasks?\n#SBATCH --cpus-per-task=4     # Number of CPUs per task\n#SBATCH --gres=gpu:4          # Number of GPUs\nsrun julia -p 4 main.jl","category":"page"}]
}
